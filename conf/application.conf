# https://www.playframework.com/documentation/latest/Configuration
play.http.secret.key="changeme"

slick.dbs {
  default {
    profile = "clickhouse.ClickHouseProfile$"
    db {
      driver = "ru.yandex.clickhouse.ClickHouseDriver"
      url = "jdbc:clickhouse://127.0.0.1:8123"
      numThreads = 4
      queueSize = 128
      maxConnections = 4
    }
  }
}

ot {
  clickhouse {
    target {
      associations {
        label = "Association table for targets"
        name = "ot.aotf_t"
        key = "target_id"
      }

      networks = [
        {label = "Experimental P2P interaction network", name = "ot.target_network_t", key = "target_id", field = "neighbours"},
        {label = "String P2P interaction network", name = "ot.target_network_stringdb_t", key = "target_id", field = "neighbours"}
      ]
    }

    disease {
      associations {
        label = "Association table for targets"
        name = "ot.aotf_d"
        key = "disease_id"
      }

      networks = [
        {label = "EFO Ontology v2",name = "ot.disease_network_t", key = "disease_id", field = "neighbours"}
      ]
    }

    harmonic {
      pExponent = 2
      datasources = [
        {id: "datasource_cancer_gene_census.scores", weight = 1},
        {id: "datasource_chembl.scores", weight = 1},
        {id: "datasource_crispr.scores", weight: 1},
        {id: "datasource_europepmc.scores", weight: 0.2},
        {id: "datasource_eva.scores", weight: 1},
        {id: "datasource_eva_somatic.scores", weight: 1},
        {id: "datasource_expression_atlas.scores", weight: 0.2},
        {id: "datasource_gene2phenotype.scores", weight: 1},
        {id: "datasource_genomics_england.scores", weight: 1},
        {id: "datasource_gwas_catalog.scores", weight: 1},
        {id: "datasource_intogen.scores", weight: 1},
        {id: "datasource_phenodigm.scores", weight: 0.2},
        {id: "datasource_phewas_catalog.scores", weight: 1},
        {id: "datasource_progeny.scores", weight: 0.5},
        {id: "datasource_reactome.scores", weight: 1},
        {id: "datasource_slapenrich.scores", weight: 0.5},
        {id: "datasource_sysbio.scores", weight: 0.5},
        {id: "datasource_uniprot.scores", weight: 1},
        {id: "datasource_uniprot_literature.scores", weight: 1},
        {id: "datasource_uniprot_somatic.scores", weight: 1}
      ]
    }
//    harmonic {
//      pExponent = 2
//      datasources = [
//        {id: "cancer_gene_census", weight = 1},
//        {id: "chembl", weight = 1},
//        {id: "crispr", weight: 1},
//        {id: "europepmc", weight: 0.2},
//        {id: "eva", weight: 1},
//        {id: "eva_somatic", weight: 1},
//        {id: "expression_atlas", weight: 0.2},
//        {id: "gene2phenotype", weight: 1},
//        {id: "genomics_england", weight: 1},
//        {id: "gwas_catalog", weight: 1},
//        {id: "intogen", weight: 1},
//        {id: "phenodigm", weight: 0.2},
//        {id: "phewas_catalog", weight: 1},
//        {id: "progeny", weight: 0.5},
//        {id: "reactome", weight: 1},
//        {id: "slapenrich", weight: 0.5},
//        {id: "sysbio", weight: 0.5},
//        {id: "uniprot", weight: 1},
//        {id: "uniprot_literature", weight: 1},
//        {id: "uniprot_somatic", weight: 1}
//      ]
//    }
  }

  elasticsearch {
    host = "localhost"
    port = 9200
    entities = [
      {
        name = "evidence_drug_direct"
        index = "20.04_evidence_drug_direct"
      },
      {
        name = "disease_relation"
        index = "20.04_disease_relation"
      },
      {
        name = "target_relation"
        index = "20.04_target_relation"
      },
      {
        name = "faers"
        index = "20.04_openfda_faers"
      },
      {
        name = "eco"
        index = "20.04_eco"
      },
      {
        name = "cancerBiomarker"
        index = "20.04_cancerbiomarker"
      },
      {
        name = "target"
        index = "20.04_target"
        searchIndex = "20.04_search_target"
      },
      {
        name = "disease"
        index = "20.04_disease"
        searchIndex = "20.04_search_disease"
      },
      {
        name = "drug"
        index = "20.04_drug"
        searchIndex = "20.04_search_drug"
      }
    ]
    highlightFields = [
      "id",
      "keywords",
      "name",
      "description",
      "prefixes",
      "terms",
      "terms5",
      "terms25",
      "ngrams"
    ]
  }

  meta {
    name = "Open Targets GraphQL & REST API Beta"
    apiVersion {
      x = 0
      y = 25
      z = 0
    }
    dataVersion {
      year = 20
      month = 04
      iteration = 0
    }
  }
}

play.filters.disabled += play.filters.csrf.CSRFFilter
play.filters.disabled += play.filters.headers.SecurityHeadersFilter
play.filters.disabled += play.filters.csp.CSPFilter
play.filters.enabled += play.filters.hosts.AllowedHostsFilter
play.filters.enabled += play.filters.cors.CORSFilter

play {
  server {
    akka {
      max-header-value-length = 16k
    }
  }

  filters {
    hosts {

      # A list of valid hosts (e.g. "example.com") or suffixes of valid hosts (e.g. ".example.com")
      # Note that ".example.com" will match example.com and any subdomain of example.com, with or without a trailing dot.
      # "." matches all domains, and "" matches an empty or nonexistent host.
      allowed = ["."]
    }
    cors {
      pathPrefixes = ["/"]
      supportsCredentials = false
    }
    # GZip filter configuration
    gzip {

      # The buffer size to use for gzipped bytes
      bufferSize = 8k

      # The maximum amount of content to buffer for gzipping in order to calculate the content length before falling back
      # to chunked encoding.
      chunkedThreshold = 100k

      contentType {

        # If non empty, then a response will only be compressed if its content type is in this list.
        whiteList = []

        # The black list is only used if the white list is empty.
        # Compress all responses except the ones whose content type is in this list.
        blackList = []
      }
    }
  }
}

akka.http {
  parsing {
    max-uri-length = 16k
  }
}
